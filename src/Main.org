Deze demonstratie app gaat om het schrijven van threepenny layer voor de film app.
Als dat eenmaal wat werkt moet het omschrijven naar een knowledge graph niet veel moeilijker zijn.

Dit wordt vooral gedaan doordat we nu veel en gestructureerde data hebben. Interactie hiermee maakt onze eigen model wellicht makkelijker.

Het andere experiment wat hiermee wordt aangegaan is vanaf het begin programmeren in literate style.


* Imports 
#+begin_src haskell :tangle ./Main.hs :comments both
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecursiveDo #-}
module Main where
import Data.Default
import qualified Database.Bolt as B
import Graphics.UI.Threepenny as GUT
import qualified Data.Text as T
import Control.Monad 
import Data.Aeson
import qualified Data.ByteString.Lazy.Char8 as BS
import Data.Monoid ((<>))
#+end_src 

* Neo4j

#+begin_src haskell :tangle ./Main.hs :comments both

settings = def {B.user="neo4j", B.password="pki2018"}

doquery :: IO ()
doquery = do
  pipe <- B.connect settings
  let q = B.query "match (movie:Movie) return movie limit 4;"
  res <- B.run pipe q
  print res
  let first = head res
  bla <- first `B.at` "movie" >>= B.exact :: IO B.Node
  print bla
#+end_src

* GUI
:PROPERTIES:
:header-args: :tangle ./Main.hs :comments both
:END:

#+begin_src haskell 
  main :: IO ()
  main = do 
    startGUI defaultConfig {jsStatic = Just ".", jsPort = Just 8200} setup

  setup :: Window -> UI ()
  setup w = void $ do
    return w # set title "test neo4j"
    sigmael <- createSigma
    parentinput <- createInputField "pinput" "Parent" 
    getBody w #+ [element sigmael, element parentinput]
    
#+end_src

** input
De GUI output is vrijwel hetzelfde voor het invoeren van een nieuwe node voor alleenstaand, child, parent en relatie.
De tekst verschilt een beetje maar het is vooral de actie die verschilt.


#+begin_src haskell
  -- classid, text, functie
  createInputField :: T.Text -> T.Text -> UI Element
  createInputField classid msg = mdo
    g <- GUT.div # set id_ (T.unpack classid)
    b <- button # set text "add"

    uinput <- entry binput

    binput <- stepper "" . rumors $ userText uinput
    debugstring <- string "Nothing"
    sink text (facts $ userText uinput) (element debugstring)
    element g #+ [string (T.unpack msg), element uinput,element b, element debugstring] 
#+end_src
** sigmajs

#+begin_src haskell
  createSigma :: UI Element
  createSigma = do
    g <- GUT.div # set id_ "scontainer"
    graph <- GUT.div # set id_ "sg" # set style [("margin", "auto")]
    s <- string "Hello world"
    b <- button # set text "Appear"
    
    let js = BS.unpack $ encode testSG
    let command = ("s.graph.clear();\n" <>
                   "s.graph.read(" ++ js ++ ");\n" <>
                   "s.refresh();\n" <>
                   "s.startNoverlap();")

    on click b (\a -> runFunction $ ffi command)

    sgm <- mkElement "script" # set (attr "src") "/static/sigma.js/build/sigma.min.js"
    sset <- mkElement "script" # set (attr "src") "/static/src/sig.js"
    slayout <- mkElement "script" # set (attr "src") "/static/sigma.js/build/plugins/sigma.layout.noverlap.min.js"
    sani <- mkElement "script" # set (attr "src") "/static/sigma.js/build/plugins/sigma.plugins.animate.min.js"

    st <- mkElement "style" # set (attr "type") "text/css" # set html  "#sg {max-width: 400px; height: 400px; margin: auto;}"
    element g #+ [element st, element graph, element s, element sgm, element sani, element slayout, element sset, element b]
#+end_src

sigma moet maar een keer worden aangeroepen anders wordt er steeds weer een canvas aan de div toegevoegd.
De clear is waarschijnlijk ook nodig doordat alle parser die read gebruiken dit er ook bij hebben.

De volgorde waarin de script worden geladen is belangrijk. Anders bestaan sommige element niet.

* Datastructures
:PROPERTIES:
:header-args: :tangle ./Main.hs :comments both
:END:

Zijn labels ieders aparte dingen zoals nu, of is het beter om het te modelleren als de ADT en dat een node meerdere van deze labels kan hebben.

Dat gebeurt echter ook wel als we aan de hasbolt interface blijven zitten. Het huidige is misschien beter om de data te transformeren.

** sigma.js
We maken een data structuur voor sigma.js die we eenvoudig van en naar JSON kunnen maken.
Hoewel we waarschijnlijk ongerichte grafen blijven tekenen, kent sigmajs wel source and target id en wij hanteren het ook om tijdens het coden consistent te blijven.

#+begin_src haskell

data SG = SG [SNode] [SEdge]

type ID = Int
type Label = T.Text

type SourceID = ID
type TargetID = ID

data SNode = SN ID Label
data SEdge = SE ID SourceID TargetID

instance ToJSON SG where
  toJSON (SG n e) = object ["nodes" .= toJSON n, "edges" .= toJSON e]

instance ToJSON SEdge where
  toJSON (SE id source target) = object ["id" .= id, "source" .= source, "target" .= target]

instance ToJSON SNode where
  toJSON (SN id label) = object ["id" .= id, "label" .= label, "x" .= (20 :: Int), "y" .= (30 :: Int), "size" .= (10 :: Int)]
#+end_src

De nodes hebben wel echt een positie nodig anders worden ze niet getekend. Ook wanneer er sprake is van nooverlap
Het maken van een node moet pas gebeuren wanneer de browser geheel is geladen.

In het voorbeeld op de site maken ze gebruik van aparte identifiers voor edges en nodes. We hanteren eerst Ints en zien wel of we ze ook op dit level moeten onderscheiden.

#+begin_src haskell
testSG :: SG
testSG = SG [SN 1 "Henk", SN 2 "Frits", SN 3 "Barend"] [SE 1 1 2]
#+end_src



















