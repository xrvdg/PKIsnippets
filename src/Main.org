Deze demonstratie app gaat om het schrijven van threepenny layer voor de film app.
Als dat eenmaal wat werkt moet het omschrijven naar een knowledge graph niet veel moeilijker zijn.

Dit wordt vooral gedaan doordat we nu veel en gestructureerde data hebben. Interactie hiermee maakt onze eigen model wellicht makkelijker.

Het andere experiment wat hiermee wordt aangegaan is vanaf het begin programmeren in literate style.

* IO
It is still to be decided whether the database actions are going to be handled inside each module themselfs. Or that it is going to be encoded as operations back to main.

* Imports 
#+begin_src haskell :tangle ./Main.hs :comments both
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecursiveDo #-}
module Main where
import Data.Default
import qualified Database.Bolt as B
import Graphics.UI.Threepenny as GUT
import qualified Data.Text as T
import Control.Monad 
import Data.Aeson
import qualified Data.ByteString.Lazy.Char8 as BS
import Data.Monoid ((<>))
import Control
#+end_src 

* Neo4j

#+begin_src haskell :tangle ./Main.hs :comments both

settings = def {B.user="neo4j", B.password="pki2018"}

doquery :: IO ()
doquery = do
  pipe <- B.connect settings
  let q = B.query "match (movie:Movie) return movie limit 4;"
  res <- B.run pipe q
  print res
  let first = head res
  bla <- first `B.at` "movie" >>= B.exact :: IO B.Node
  print bla
#+end_src

* GUI
:PROPERTIES:
:header-args: :tangle ./Main.hs :comments both
:END:

#+begin_src haskell 
  main :: IO ()
  main = do 
    pipe <- B.connect settings
    startGUI defaultConfig {jsStatic = Just ".", jsPort = Just 8200} (setup pipe)

  setup :: B.Pipe -> Window -> UI ()
  setup p w = void $ do
    return w # set title "test neo4j"
    sigmael <- createSigma
    getBody w #+ [element sigmael, controlView]
    
#+end_src

** input
De GUI output is vrijwel hetzelfde voor het invoeren van een nieuwe node voor alleenstaand, child, parent en relatie.
De tekst verschilt een beetje maar het is vooral de actie die verschilt.

Ervoor gekozen dat het submitten het event is, wel sturen we de text mee. 

Voorheen was het idee om de nog niet submitted input het event te maken zodat autocompletion kan worden gedaan.
Maar dat is wellicht meer voor binnen een widget zelf en niet buiten een widget.
#+begin_src haskell
data TextForm = TF { elemTF :: Element, userTF :: Tidings T.Text} 

submitted :: TextForm -> Tidings T.Text
submitted = userTF 

instance Widget TextForm where
  getElement = elemTF 

--    let q = \a -> B.query ("CREATE (n: Concept{longtitle: \"" <> (T.pack a) <> "\"} )")
--   on ((binput <@) . click) b (\a -> liftIO $ B.run p (q a))

-- classid, text, functie
textform :: T.Text -> T.Text -> UI TextForm
textform classid msg = mdo
  g <- GUT.div # set id_ (T.unpack classid)
  b <- button # set text "Add"

  uinput <- entry binput
  let einput = rumors $ userText uinput
  binput <- stepper "" (head <$> unions [einput , "" <$ click b])

  element g #+ [string (T.unpack msg), element uinput,element b] 
  return $ TF g (tidings (T.pack <$> binput) (T.pack <$> einput))
#+end_src

NOTE: dit had waarschijnlijk ook gemaakt kunnen worden met een html form.
NOTE: misschien is het beter als het alleen een event is. Nu heeft het state buiten het submitten om.

** sigmajs

#+begin_src haskell
  createSigma :: UI Element
  createSigma = do
    g <- GUT.div # set id_ "scontainer"
    graph <- GUT.div # set id_ "sg" # set style [("margin", "auto")]
    s <- string "Hello world"
    b <- button # set text "Appear"
    
    let js = BS.unpack $ encode testSG
    let command = ("s.graph.clear();\n" <>
                   "s.graph.read(" ++ js ++ ");\n" <>
                   "s.refresh();\n" <>
                   "s.startNoverlap();")

    on click b (\a -> runFunction $ ffi command)

    sgm <- mkElement "script" # set (attr "src") "/static/sigma.js/build/sigma.min.js"
    sset <- mkElement "script" # set (attr "src") "/static/src/sig.js"
    slayout <- mkElement "script" # set (attr "src") "/static/sigma.js/build/plugins/sigma.layout.noverlap.min.js"
    sani <- mkElement "script" # set (attr "src") "/static/sigma.js/build/plugins/sigma.plugins.animate.min.js"

    st <- mkElement "style" # set (attr "type") "text/css" # set html  "#sg {max-width: 400px; height: 400px; margin: auto;}"
    element g #+ [element st, element graph, element s, element sgm, element sani, element slayout, element sset, element b]
#+end_src

sigma moet maar een keer worden aangeroepen anders wordt er steeds weer een canvas aan de div toegevoegd.
De clear is waarschijnlijk ook nodig doordat alle parser die read gebruiken dit er ook bij hebben.

De volgorde waarin de script worden geladen is belangrijk. Anders bestaan sommige element niet.

* Datastructures
:PROPERTIES:
:header-args: :tangle ./Main.hs :comments both
:END:

Zijn labels ieders aparte dingen zoals nu, of is het beter om het te modelleren als de ADT en dat een node meerdere van deze labels kan hebben.

Dat gebeurt echter ook wel als we aan de hasbolt interface blijven zitten. Het huidige is misschien beter om de data te transformeren.

** sigma.js
We maken een data structuur voor sigma.js die we eenvoudig van en naar JSON kunnen maken.
Hoewel we waarschijnlijk ongerichte grafen blijven tekenen, kent sigmajs wel source and target id en wij hanteren het ook om tijdens het coden consistent te blijven.

#+begin_src haskell

data SG = SG [SNode] [SEdge]

type ID = Int
type Label = T.Text

type SourceID = ID
type TargetID = ID

data SNode = SN ID Label
data SEdge = SE ID SourceID TargetID

instance ToJSON SG where
  toJSON (SG n e) = object ["nodes" .= toJSON n, "edges" .= toJSON e]

instance ToJSON SEdge where
  toJSON (SE id source target) = object ["id" .= id, "source" .= source, "target" .= target]

instance ToJSON SNode where
  toJSON (SN id label) = object ["id" .= id, "label" .= label, "x" .= (20 :: Int), "y" .= (30 :: Int), "size" .= (10 :: Int)]
#+end_src

De nodes hebben wel echt een positie nodig anders worden ze niet getekend. Ook wanneer er sprake is van nooverlap
Het maken van een node moet pas gebeuren wanneer de browser geheel is geladen.

In het voorbeeld op de site maken ze gebruik van aparte identifiers voor edges en nodes. We hanteren eerst Ints en zien wel of we ze ook op dit level moeten onderscheiden.

#+begin_src haskell
testSG :: SG
testSG = SG [SN 1 "Henk", SN 2 "Frits", SN 3 "Barend"] [SE 1 1 2]
#+end_src




* Knowledge graph
** introduction
Een node in het netwerk kan een concept (C) of relation omschrijven (R). 
Er is geen hard verschil tussen deze twee dingen een relatie is voornamelijk anders doordat we niet vereisen dat deze een naam heeft.
Wanneer een naam toch nodig wordt dan kan een relation worden gelift naar een concept.

De terminologie staat nog niet helemaal vast.

Binnen dit systeem is er een verschil tussen een relation en een edge. Een relation is een extra node die het mogelijk maakt om meerdere soorten nodes (concepts en relations) aan elkaar te kunnen linken om een rijkere context te kunnen creëren.

** datastructure
Er mag geen overlap zitten tussen ID van C en R in de database doordat het als gelijke soort data wordt gezien.

#+begin_src haskell
type LongName = T.Text
data Node = C LongName T.Text | R T.Text

data NeoNode = NN ID Node
data NeoRel = NR ID ID ID 
#+end_src 

Voor nu maken we gebruik van eenvoudige relaties, maar in de toekomst moet er ruimte zijn om vermoedens en dergelijken aan te kunnen geven.
Verder hanteren we alleen een LongName op het moment. In de toekomst moet er ook een shortname komen zodat we de namen bij nodes klein kunnen houden.

Het idee van de longname is dat we deze ook uniek kunnen houden.

Ook zet de huidige methode het geheel vast op één label. We moeten eens kijken of dit te limiterend werkt.

* Conversion
Vanuit Neo4j hasbolt krijgen we eerst een blob data van het type record
#+begin_src haskell :export none
type Record = Map Text Value
#+end_src

Waar Text de naam van de identifier is die je hebt gebruikt in je query en value een structuur is. In deze structuur wordt er geen onderscheid gemaakt tussen primitieve datatypes, nodes en edges.
Daarvoor gebruik je de "exact" functie die onderdeel uitmaakt van de recordtypes typeclass.

Stap één is dus ook het converteren van deze ongestructureerde data naar nodes en relationships.


collect function en dan een toNodes schrijven

* TODOs
** invoer
*** database connection
*** DONE GUI
    CLOSED: [2018-01-08 Mon 15:28]
*** parent
*** child
*** friendship
** zoeken
** DONE data verwijderen uit database
   CLOSED: [2018-01-08 Mon 14:37]
** test data invoeren
