* Controller
:PROPERTIES:
:header-args: :tangle ./Control.hs :comments both
:END:

This module is responsible for registering actions that change the state of the module. 

This module communicates to the Text en Graph part by sending the currently selected node and whether or not the underlying database has been updated.
The currently selected node is always interesting for the other parts, the update might or might not change the the neighbouring GUI elements.

** imports etc
#+begin_src haskell
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecursiveDo #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
module Control (
  controlView
)
where

import qualified Data.Text as T
import Graphics.UI.Threepenny as GUT
import Debug
import qualified Forms.AddRemove as ARF
import Control.Distributed.Process.Node
import Control.Distributed.Process.Serializable
import Control.Distributed.Process
import Control.Concurrent (threadDelay)
import Control.Monad (void)
#+end_src

** Operations
The forms are used for multiple operations in controlView these form get a meaning assigned to them.

Where in ADD the second is dependent on the first.

#+begin_src haskell
{-
||| A process server that has a single task.
-}
processTask :: Serializable a => (a -> IO b) -> Process ()
processTask f = do a <- expect
                   liftIO (f a)
                   processTask f

{-
||| A process server with a single tasks that executes handler when the function is done.
-}
handlerProcessTask :: Serializable a => GUT.Handler b -> (a -> IO b) -> Process ()
handlerProcessTask h f = processTask (\a -> f a >>= h)

onEventProcess :: Serializable a => LocalNode -> Event a -> (a -> IO b) -> (b -> UI void) -> UI ()
onEventProcess nid event rf gf = void $  do 
       (callbackev, fire) <- liftIO newEvent 
       pid <- liftIO $ forkProcess nid (handlerProcessTask fire rf)
       onEvent event (\a -> liftIO . runProcess nid $ send pid a)
       onEvent callbackev gf

data Operation = Select String | Remove String | 
                 AddLink String String | RmLink String String | 
                 AddRel String String | RmRel String String deriving Show

controlView :: LocalNode -> UI Element
controlView ln = do 
                 regular <- ARF.mkAddRemove "regular"
                 bCurrent <- stepper Nothing (ARF.getText ARF.isADD <$> ARF.ev regular)
                 parent <- ARF.mkAddRemove "parent"
                 child <- ARF.mkAddRemove "child"
                 relation <- ARF.mkAddRemove "relation"
                 status <- string "No status yet"
                 let delay = 10000000
                 onEventProcess ln (ARF.ev regular) (\a -> threadDelay delay >> return  (show a ++ show delay)) (\b -> element status # set text b)
                 new #+ [element status, element regular, element parent, element child, element relation]
#+end_src

* Form

#+begin_src haskell :tangle ./Forms/AddRemove.hs :comments both
  {-# LANGUAGE DeriveAnyClass #-}
  {-# LANGUAGE DeriveGeneric #-}
  {-# LANGUAGE RecursiveDo #-}
  module Forms.AddRemove (
    isADD,
    isRM,
    getText,
    mkAddRemove,
    ev
  )
  where

  import Graphics.UI.Threepenny
  import Debug
  import GHC.Generics
  import Data.Binary
  import Data.Typeable

  data ADDRM = ADD String | RM String deriving (Show, Generic, Binary, Typeable)


  isADD :: ADDRM -> Bool
  isADD (ADD e) = True
  isADD _ = False

  isRM :: ADDRM -> Bool
  isRM (RM e) = True
  isRM _ = False

  getText :: (ADDRM -> Bool) -> ADDRM -> Maybe String
  getText p op = if p op then Just (getText' op) else Nothing

  getText' :: ADDRM -> String
  getText' (ADD str) = str
  getText' (RM str) = str

  data AddRemoveForm = ARF {elemARF :: Element, ev :: Event ADDRM}

  mkAddRemove :: String -> UI AddRemoveForm
  mkAddRemove title = mdo 
                           f <- new # set class_ "addremove"
                           header <- string title 

                           add <- button # set text "add" 
                           remove <- button # set text "remove" 
                           let eadd = click add
                               eremove = click remove

                           uinput <- entry binput
                           let einput = rumors $ userText uinput
                           binput <- stepper "" einput 

                           let eoutput = head <$> unions [ADD <$> binput <@ eadd, RM <$> binput <@ eremove]

                           lastAction <- stepper "" (show <$> eoutput)
                         
                           db <- debugString "Nothing"
                           sink text lastAction (element db)

                           element f #+ [element header, element uinput, element add, element remove, element db]
                           return (ARF f eoutput)

  instance Widget AddRemoveForm where
    getElement = elemARF
#+end_src
